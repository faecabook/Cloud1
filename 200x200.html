<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>Image Editor + Multi Images + 200x200 Preview</title>
<style>
    body {
        font-family: sans-serif;
        display: flex;
        gap: 20px;
    }
    #editorArea {
        border: 1px solid #ccc;
        position: relative;
    }
    canvas {
        background: #f0f0f0;
        cursor: pointer;
    }
    #previewBox {
        border: 2px solid #000;
        width: 200px;
        height: 200px;
        overflow: hidden;
    }
    #previewCanvas {
        width: 200px;
        height: 200px;
    }
</style>
</head>
<body>

<div>
    <h3>ตัวแก้ไขรูป</h3>

    <input type="file" id="uploadBackground" accept="image/*"><br><br>
    <input type="file" id="uploadDecoration" accept="image/*"><br><br>

    <button onclick="addText()">เพิ่มข้อความ</button>
    <button onclick="downloadImage()">ดาวน์โหลด PNG</button>

    <br><br>

    <div id="editorArea">
        <canvas id="mainCanvas" width="500" height="500"></canvas>
    </div>
</div>

<div>
    <h3>ตัวอย่าง 200×200</h3>
    <div id="previewBox">
        <canvas id="previewCanvas" width="200" height="200"></canvas>
    </div>
</div>

<script>
let canvas = document.getElementById("mainCanvas");
let ctx = canvas.getContext("2d");

let previewCanvas = document.getElementById("previewCanvas");
let pctx = previewCanvas.getContext("2d");

let objects = []; // เก็บทุก layer: background, decoration, text
let selected = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

// โหลด background
document.getElementById("uploadBackground").addEventListener("change", function (e) {
    let file = e.target.files[0];
    if (!file) return;
    let reader = new FileReader();
    reader.onload = function (evt) {
        let img = new Image();
        img.onload = function () {
            objects[0] = { type: "image", img: img, x:0, y:0, w: canvas.width, h: canvas.height };
            draw();
        };
        img.src = evt.target.result;
    };
    reader.readAsDataURL(file);
});

// โหลด decoration
document.getElementById("uploadDecoration").addEventListener("change", function (e) {
    let file = e.target.files[0];
    if (!file) return;
    let reader = new FileReader();
    reader.onload = function (evt) {
        let img = new Image();
        img.onload = function () {
            objects.push({ type:"image", img: img, x:50, y:50, w:100, h:100 });
            draw();
        };
        img.src = evt.target.result;
    };
    reader.readAsDataURL(file);
});

// วาดทุก layer
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for (let obj of objects) {
        if (obj.type === "image") ctx.drawImage(obj.img, obj.x, obj.y, obj.w, obj.h);
        else if (obj.type === "text") {
            ctx.font = obj.size + "px Arial";
            ctx.fillStyle = obj.color;
            ctx.fillText(obj.text, obj.x, obj.y);
        }
    }
    updatePreview();
}

// พรีวิว 200x200
function updatePreview() {
    pctx.clearRect(0,0,200,200);
    pctx.drawImage(canvas, 0,0,200,200);
}

// เพิ่มข้อความ
function addText() {
    let text = prompt("พิมพ์ข้อความ:");
    if (!text) return;
    objects.push({ type:"text", text:text, x:50, y:50, size:30, color:"red" });
    draw();
}

// ดาวน์โหลด PNG
function downloadImage() {
    let link = document.createElement("a");
    link.download = "edited.png";
    link.href = canvas.toDataURL();
    link.click();
}

// เลือกและลาก
canvas.addEventListener("mousedown", e=>{
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    for (let i = objects.length-1; i>=0; i--) {
        let o = objects[i];
        if (o.type==="image" && mx>=o.x && mx<=o.x+o.w && my>=o.y && my<=o.y+o.h) {
            selected = o;
            dragOffsetX = mx - o.x;
            dragOffsetY = my - o.y;
            return;
        } else if (o.type==="text") {
            ctx.font = o.size + "px Arial";
            const w = ctx.measureText(o.text).width;
            const h = o.size;
            if (mx>=o.x && mx<=o.x+w && my<=o.y && my>=o.y-h) {
                selected=o;
                dragOffsetX = mx - o.x;
                dragOffsetY = my - o.y;
                return;
            }
        }
    }
    selected=null;
});

canvas.addEventListener("mousemove", e=>{
    if (!selected) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    selected.x = mx - dragOffsetX;
    selected.y = my - dragOffsetY;
    draw();
});

canvas.addEventListener("mouseup", e=>{ selected=null; });
canvas.addEventListener("mouseleave", e=>{ selected=null; });

</script>
</body>
</html>
