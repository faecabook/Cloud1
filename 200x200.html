<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>Image Editor with Border Toggle & Delete</title>
<style>
body { font-family:sans-serif; display:flex; gap:20px; }
#editorArea { border:1px solid #ccc; position:relative; }
canvas { background:#f0f0f0; cursor:pointer; }
#previewBox { border:2px solid #000; width:200px; height:200px; overflow:hidden; }
#previewCanvas { width:200px; height:200px; }
</style>
</head>
<body>

<div>
<h3>ตัวแก้ไขรูป</h3>

<input type="file" id="uploadBackground" accept="image/*"><br><br>
<input type="file" id="uploadImage1" accept="image/*"><br>
<input type="file" id="uploadImage2" accept="image/*"><br>
<input type="file" id="uploadImage3" accept="image/*"><br><br>

<label><input type="checkbox" id="keepAspect"> คงอัตราส่วนเดิม</label><br>
<label><input type="checkbox" id="toggleBorder"> แสดง/ซ่อนกรอบวัตถุ</label><br>
<input type="color" id="borderColor" value="#000000"> เลือกสีกรอบ<br><br>

<button onclick="addText()">เพิ่มข้อความ</button>
<button onclick="downloadImage()">ดาวน์โหลด PNG</button>

<br><br>
<div id="editorArea">
    <canvas id="mainCanvas" width="500" height="500"></canvas>
</div>
</div>

<div>
<h3>ตัวอย่าง 200×200</h3>
<div id="previewBox">
    <canvas id="previewCanvas" width="200" height="200"></canvas>
</div>
</div>

<script>
let canvas=document.getElementById("mainCanvas");
let ctx=canvas.getContext("2d");
let previewCanvas=document.getElementById("previewCanvas");
let pctx=previewCanvas.getContext("2d");

let objects=[]; 
let selected=null;
let dragOffsetX=0, dragOffsetY=0;
let resizing=false;
let aspectRatio=1;

// โหลดรูป
function loadImage(file, callback){
    if(!file) return;
    let reader=new FileReader();
    reader.onload=function(evt){
        let img=new Image();
        img.onload=function(){ callback(img); };
        img.src=evt.target.result;
    };
    reader.readAsDataURL(file);
}

// background
document.getElementById("uploadBackground").addEventListener("change",e=>{
    loadImage(e.target.files[0], img=>{
        objects[0]={type:"image", img:img, x:0,y:0,w:canvas.width,h:canvas.height,border:false,borderColor:"#000"};
        draw();
    });
});

// decoration 3 รูป
["uploadImage1","uploadImage2","uploadImage3"].forEach(id=>{
    document.getElementById(id).addEventListener("change", e=>{
        loadImage(e.target.files[0], img=>{
            let w=100,h=100;
            objects.push({type:"image", img:img, x:50, y:50, w:w, h:h, border:true, borderColor:document.getElementById("borderColor").value});
            draw();
        });
    });
});

// เพิ่มข้อความ
function addText(){
    let text=prompt("พิมพ์ข้อความ:");
    if(!text) return;
    objects.push({type:"text", text:text, x:50, y:50, size:30, color:"red", border:true, borderColor:"#000"});
    draw();
}

// วาด layer + preview
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    let showBorder=document.getElementById("toggleBorder").checked;
    for(let obj of objects){
        if(obj.type==="image"){
            ctx.drawImage(obj.img,obj.x,obj.y,obj.w,obj.h);
            if(obj.border && showBorder){
                ctx.strokeStyle=obj.borderColor;
                ctx.lineWidth=3;
                ctx.strokeRect(obj.x,obj.y,obj.w,obj.h);
            }
        } else if(obj.type==="text"){
            ctx.font=obj.size+"px Arial";
            ctx.fillStyle=obj.color;
            ctx.fillText(obj.text,obj.x,obj.y);
            if(obj.border && showBorder){
                ctx.strokeStyle=obj.borderColor;
                ctx.lineWidth=2;
                ctx.strokeRect(obj.x,obj.y-obj.size,ctx.measureText(obj.text).width,obj.size);
            }
        }
    }
    drawHandles();
    updatePreview();
}

// พรีวิว 200x200
function updatePreview(){
    pctx.clearRect(0,0,200,200);
    pctx.drawImage(canvas,0,0,200,200);
}

// ดาวน์โหลด PNG
function downloadImage(){
    let link=document.createElement("a");
    link.download="edited.png";
    link.href=canvas.toDataURL();
    link.click();
}

// เลือก/ลาก/ย่อขยาย
canvas.addEventListener("mousedown", e=>{
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    for(let i=objects.length-1;i>=0;i--){
        let o=objects[i];
        if(o.type==="image" && mx>=o.x && mx<=o.x+o.w && my>=o.y && my<=o.y+o.h){
            selected=o;
            dragOffsetX=mx-o.x;
            dragOffsetY=my-o.y;
            aspectRatio=o.w/o.h;
            if(Math.abs(mx-(o.x+o.w))<10 && Math.abs(my-(o.y+o.h))<10) resizing=true;
            return;
        }
        else if(o.type==="text"){
            ctx.font=o.size+"px Arial";
            const w=ctx.measureText(o.text).width;
            const h=o.size;
            if(mx>=o.x && mx<=o.x+w && my<=o.y && my>=o.y-h){
                selected=o;
                dragOffsetX=mx-o.x;
                dragOffsetY=my-o.y;
                aspectRatio=w/h;
                if(Math.abs(mx-(o.x+w))<10 && Math.abs(my-(o.y))<10) resizing=true;
                return;
            }
        }
    }
    selected=null;
    draw();
});

canvas.addEventListener("mousemove", e=>{
    if(!selected) return;
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    let keepAspect=document.getElementById("keepAspect").checked;
    if(resizing){
        if(selected.type==="image"){
            if(keepAspect){
                let newW=Math.max(10,mx-selected.x);
                let newH=newW/aspectRatio;
                selected.w=newW;
                selected.h=newH;
            } else {
                selected.w=Math.max(10,mx-selected.x);
                selected.h=Math.max(10,my-selected.y);
            }
        } else if(selected.type==="text"){
            selected.size=Math.max(10,my-selected.y);
        }
    } else {
        selected.x=mx-dragOffsetX;
        selected.y=my-dragOffsetY;
    }
    draw();
});

canvas.addEventListener("mouseup", e=>{
    selected=null; resizing=false;
});

canvas.addEventListener("mouseleave", e=>{
    selected=null; resizing=false;
});

// วาด handle
function drawHandles(){
    if(!selected) return;
    ctx.save();
    ctx.strokeStyle="blue";
    ctx.lineWidth=2;
    if(selected.type==="image"){
        ctx.strokeRect(selected.x,selected.y,selected.w,selected.h);
        ctx.fillStyle="blue";
        ctx.fillRect(selected.x+selected.w-5,selected.y+selected.h-5,10,10);
    } else if(selected.type==="text"){
        ctx.strokeRect(selected.x,selected.y-selected.size,ctx.measureText(selected.text).width,selected.size);
        ctx.fillStyle="blue";
        ctx.fillRect(selected.x+ctx.measureText(selected.text).width-5,selected.y-5,10,10);
    }
    ctx.restore();
}

// เปลี่ยนสีกรอบ
document.getElementById("borderColor").addEventListener("input", e=>{
    if(selected) selected.borderColor=e.target.value;
    draw();
});

// ลบวัตถุด้วย Delete
window.addEventListener("keydown", e=>{
    if(e.key==="Delete" && selected){
        objects = objects.filter(o => o!==selected);
        selected=null;
        draw();
    }
});
</script>

</body>
</html>
