<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>Image Editor + Fixed Resize + Border + Preview</title>
<style>
body {
    font-family: sans-serif;
    display: flex;
    gap: 20px;
}
#editorArea {
    border: 1px solid #ccc;
    position: relative;
}
canvas {
    background: #f0f0f0;
    cursor: pointer;
}
#previewBox {
    border: 2px solid #000;
    width: 200px;
    height: 200px;
    overflow: hidden;
}
#previewCanvas {
    width: 200px;
    height: 200px;
}
.controls {
    margin-bottom: 10px;
}
</style>
</head>
<body>

<div>
    <h3>ตัวแก้ไขรูป</h3>

    <div class="controls">
        <input type="file" id="uploadBackground" accept="image/*"><br><br>
        <input type="file" id="uploadDecoration" accept="image/*"><br><br>

        <label>ความกว้าง:</label><input type="number" id="fixedWidth" value="100">
        <label>ความสูง:</label><input type="number" id="fixedHeight" value="100">
        <label>สีกรอบ:</label><input type="color" id="borderColor" value="#ff0000">
        <button onclick="addText()">เพิ่มข้อความ</button>
        <button onclick="downloadImage()">ดาวน์โหลด PNG</button>
    </div>

    <div id="editorArea">
        <canvas id="mainCanvas" width="500" height="500"></canvas>
    </div>
</div>

<div>
    <h3>ตัวอย่าง 200×200</h3>
    <div id="previewBox">
        <canvas id="previewCanvas" width="200" height="200"></canvas>
    </div>
</div>

<script>
let canvas = document.getElementById("mainCanvas");
let ctx = canvas.getContext("2d");
let previewCanvas = document.getElementById("previewCanvas");
let pctx = previewCanvas.getContext("2d");

let objects = []; // เก็บทุก layer
let selected = null;
let dragOffsetX=0, dragOffsetY=0;
let resizing=false;

// อัปโหลด background
document.getElementById("uploadBackground").addEventListener("change", e=>{
    let file=e.target.files[0];
    if(!file) return;
    let reader=new FileReader();
    reader.onload=function(evt){
        let img=new Image();
        img.onload=function(){
            objects[0]={type:"image", img:img, x:0, y:0, w:canvas.width, h:canvas.height, borderColor:""};
            draw();
        };
        img.src=evt.target.result;
    };
    reader.readAsDataURL(file);
});

// อัปโหลด decoration
document.getElementById("uploadDecoration").addEventListener("change", e=>{
    let file=e.target.files[0];
    if(!file) return;
    let reader=new FileReader();
    reader.onload=function(evt){
        let img=new Image();
        img.onload=function(){
            const w = Number(document.getElementById("fixedWidth").value) || 100;
            const h = Number(document.getElementById("fixedHeight").value) || 100;
            const color = document.getElementById("borderColor").value;
            objects.push({type:"image", img:img, x:50, y:50, w:w, h:h, borderColor:color});
            draw();
        };
        img.src=evt.target.result;
    };
    reader.readAsDataURL(file);
});

// เพิ่มข้อความ
function addText(){
    let text=prompt("พิมพ์ข้อความ:");
    if(!text) return;
    objects.push({type:"text", text:text, x:50, y:50, size:30, color:"red"});
    draw();
}

// วาด layer + preview
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let obj of objects){
        if(obj.type==="image"){
            ctx.drawImage(obj.img,obj.x,obj.y,obj.w,obj.h);
            if(obj.borderColor){
                ctx.strokeStyle=obj.borderColor;
                ctx.lineWidth=4;
                ctx.strokeRect(obj.x,obj.y,obj.w,obj.h);
            }
        }else if(obj.type==="text"){
            ctx.font=obj.size+"px Arial";
            ctx.fillStyle=obj.color;
            ctx.fillText(obj.text,obj.x,obj.y);
        }
    }
    drawHandles();
    updatePreview();
}

// พรีวิว 200x200
function updatePreview(){
    pctx.clearRect(0,0,200,200);
    pctx.drawImage(canvas,0,0,200,200);
}

// ดาวน์โหลด PNG
function downloadImage(){
    let link=document.createElement("a");
    link.download="edited.png";
    link.href=canvas.toDataURL();
    link.click();
}

// เลือกและลาก
canvas.addEventListener("mousedown", e=>{
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    for(let i=objects.length-1;i>=0;i--){
        let o=objects[i];
        if(o.type==="image" && mx>=o.x && mx<=o.x+o.w && my>=o.y && my<=o.y+o.h){
            selected=o;
            dragOffsetX=mx-o.x;
            dragOffsetY=my-o.y;
            // check resize (ขนาดคงที่) — ใช้ fixed w/h จาก input
            resizing=true;
            return;
        }else if(o.type==="text"){
            ctx.font=o.size+"px Arial";
            const w=ctx.measureText(o.text).width;
            const h=o.size;
            if(mx>=o.x && mx<=o.x+w && my<=o.y && my>=o.y-h){
                selected=o;
                dragOffsetX=mx-o.x;
                dragOffsetY=my-o.y;
                resizing=false;
                return;
            }
        }
    }
    selected=null;
    draw();
});

canvas.addEventListener("mousemove", e=>{
    if(!selected) return;
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    if(resizing && selected.type==="image"){
        const w = Number(document.getElementById("fixedWidth").value) || selected.w;
        const h = Number(document.getElementById("fixedHeight").value) || selected.h;
        selected.w = w;
        selected.h = h;
        selected.borderColor = document.getElementById("borderColor").value;
    }else{
        selected.x=mx-dragOffsetX;
        selected.y=my-dragOffsetY;
    }
    draw();
});

canvas.addEventListener("mouseup", e=>{ selected=null; resizing=false; });
canvas.addEventListener("mouseleave", e=>{ selected=null; resizing=false; });

// วาด handle มุมขวาล่าง
function drawHandles(){
    if(!selected) return;
    if(selected.type==="image"){
        ctx.save();
        ctx.strokeStyle="blue";
        ctx.lineWidth=2;
        ctx.strokeRect(selected.x,selected.y,selected.w,selected.h);
        ctx.fillStyle="blue";
        ctx.fillRect(selected.x+selected.w-5,selected.y+selected.h-5,10,10);
        ctx.restore();
    }else if(selected.type==="text"){
        ctx.save();
        ctx.strokeStyle="blue";
        ctx.lineWidth=2;
        ctx.strokeRect(selected.x,selected.y-selected.size,ctx.measureText(selected.text).width,selected.size);
        ctx.fillStyle="blue";
        ctx.fillRect(selected.x+ctx.measureText(selected.text).width-5,selected.y-5,10,10);
        ctx.restore();
    }
}
</script>

</body>
</html>
